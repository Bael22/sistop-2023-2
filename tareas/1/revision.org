* Los alumnos y el asesor
- ¬°Muy bien por especificar los valores de forma f√°cilmente
  parametrizable!

** Aranzua Chavez, Carranza Ochoa
- Documentaci√≥n :: [[./AranzuaChavez-CarranzaOchoa/README.md][README.md]]
- Archivos :: [[./AranzuaChavez-CarranzaOchoa/tarea1.py][tarea1.py]]
- Comentarios ::
  - Los =alumno()= no despiertan al profe s√≥lo si est√° dormido: Cada
    pregunta lleva un =despertar.release()=
    - ¬øO sera que tal vez el nombre es incorrecto? Porque el =profesor()=
      est√° despierto en todo momento (no se duerme; s√≥lo comienza
      diciendo que est√° dormido, e incrementa =aux=, con lo que su
      sue√±o s√≥lo le dura un ciclo de un =while= vac√≠o üôÅ. ¬°Pobrecito!
      üò´
    - Tendr√≠a que ser el =profesor()=, no el =alumno()=, el que
      anunciara =PROFE DORMIDO SALIENDO=, ¬øno? O en todo caso, el
      =alumno()= deber√≠a anunciar =SALIENDO= y el profe, viendo que no
      queda nadie, decir =Hora de dormir un rato=.
  - La idea de salir cuando =NUM_ALUMNOS == id+1= no es mala, pero
    puedes estar cortando algunas preguntas: Si el =alumno()= 4 tiene
    s√≥lo una pregunta y el 3 tiene 4, ¬°probablemente el =alumno()= 4
    salga antes de que el 3 haya tenido tiempo de plantear todas sus
    preguntas!
    - Salir mediante un =os._exit(0)= es una idea original e
      interesante. No te voy a decir que me encanta, sobre todo porque
      no considera a todos los dem√°s hilos, pero es efectiva üòâ
  - La interacci√≥n de plantear y responder preguntas es correcta
  - Respecto a sus preguntas:
    - Si omites el =os._exit()=, el =profesor()= se queda esperando en
      =despertar.acquire()=.
    - ¬øDe qu√© otra manera modelarlo? ¬°Acomp√°√±enme a revisar las
      entregas de sus compa√±eros! üòâ Seguro encunentran mucho m√°s si
      buscan en Internet el /problema del barbero durmiente/
      (/sleeping barber/).
    - En Python, hace falta declarar como =global= todas las variables
      que uses dentro de una funci√≥n y que pueda caber duda de d√≥nde
      vienen, esto es, cuando su primer uso dentro de una funci√≥n es
      una asignaci√≥n. Esto se hace porque en Python, al igual que en
      muchos lenguajes, se intenta que las variables pertenezcan al
      /√°mbito m√°s acotado posible/: Que se mantengan como /locales/ a
      cada funci√≥n.

      En varios lenguajes, de hecho, se pueden declarar variables
      locales a cualquier bloque, por muy anidado que est√©, y no son
      visibles fuera de √©ste.

      En el caso de ustedes, =aux= s√≥lo se usa dentro de =profesor()=,
      as√≠ que no hace falta declararla en =alumno()=. Podr√≠an no
      declarar a =aux= en la parte externa, sino que √∫nicamente dentro
      de la funci√≥n.
- Calificaci√≥n :: 8

** Armenta Fabian, Sierra Nayeli
- Documentaci√≥n :: [[./ArmentaFabian-SierraNayeli/Tarea1.txt][Tarea1.txt]]
- Archivos :: [[./ArmentaFabian-SierraNayeli/Alumno_Asesor.py][Alumno_Asesor.py]]
- Comentarios ::
  - A veces, lo que decimos los profesores no es muy √∫til... Pero en
    esta implementaci√≥n no hay ni siquiera comunicaci√≥n entre el
    =alumno()= y el =profesor()=: El alumno solito entra, pregunta,
    espera, se responde solito y decide que es hora de irse
    - El mutex =pregunta= s√≥lo evita que m√°s de un alumno est√©
      preguntando a la vez, pero no hay ninguna se√±alizaci√≥n que haga
      que el =profesor()= haga algo
    - El profesor s√≥lo hace una espera activa (aunque sea con un
      =time.sleep(0.3)=) y anuncia que se va a dormir si no ve a
      nadie, pero no emplea ning√∫n mecanismo de sincronizaci√≥n
    - Los sem√°foros =tocar_Puerta=, =dudas= y =alum= son declarados,
      pero no utilizados
  - Los √∫nicos usos de sincronizaci√≥n que veo son el multiplex
    =cubiculo= y el mutex =pregunta=.
- Calificaci√≥n :: 6

** Morales Ortega
- Documentaci√≥n :: [[./MoralesOrtega/MoralesOrtega.txt][MoralesOrtega.txt]]
- Archivos :: [[./MoralesOrtega/alumno_asesor_MOC.py][alumno_asesor_MOC.py]]
- Comentarios ::
  - Tu soluci√≥n me parece un flujo interesante. Hay un par de asuntos
    a revisar, pero me parece que va bastante de cerca de lo esperado.
    - El alumno =alu()= notifica al profesor =profe()= que tiene
      alguna. Como bien dice tu comentario, /el alumno se agarra al
      profesor para que le resuelva su duda/ usando se√±alizaci√≥n con
      el sem√°foro =profesor=. Sin embargo, parecer√≠a que plantea su
      duda y se va ‚Äî ¬°tal vez sin esperar a una respuesta! Yo
      sugerir√≠a meter una se√±alizaci√≥n m√°s, digamos =dudaResuelta=,
      que sea adquirida por =alu()= antes de =duda.release()= y
      liberada por =profe()= despu√©s de =resuelveDuda()=.
    - Cuando no hay sillas (=flag==0=), el alumno =alu()= se queda
      sentado /afuera de la oficina/. Sin embargo, ¬°s√≠ decrementa
      =numDudas=! ¬øno deber√≠a dejar a =numDudas= para que tenga sus
      dudas completas cuando entre a hablar con el =profe()=?
- Calificaci√≥n :: 8

** Organista Ricardo
- Documentaci√≥n :: [[./OrganistaRicardo/informacion.txt][informacion.txt]]
- Archivos :: [[./OrganistaRicardo/alumnos_y_asesor.py][alumnos_y_asesor.py]]
- Comentarios ::
  - Si bien manejas correctamente algunos de los puntos de
    sincronizaci√≥n (el /Multiplex/ de =sillas= y el /Mutex/ de
    =preguntando=), te faltan algunos importantes
    - Los alumnos y el profesor no /interact√∫an/: Los dos sem√°foros
      que manejas regulan la comunicaci√≥n /entre alumnos/, pero
      no hay nada que notifique al =profesor()= de que es momento de
      hacer una u otra cosa
    - Los alumnos /se responden solitos/ ‚Äî =preguntar()= es una
      funci√≥n donde el alumno entra, imprime, espera, y se va. ¬°Ser√≠a
      bueno nunca tener que resolver dudas, que a veces nos ponen en
      aprietos! Pero la realidad es bastante distinta...
    - Respecto a tu duda: No, en el planteamiento tradicional de
      sem√°foros no hay manera de conocer el contenido de una variable
      de sem√°foro.

      Algunas implementaciones s√≠ te permitir√°n ver si es /esperable/
      que puedas obtener o no un candado. Los candados en Python
      (=candado = threading.Lock()=) presentan la misma interfaz
      =acquire()/release()= que la que vimos, pero adem√°s ofrece el
      m√©todo =candado.locked()=, que regresa =True= o
      =False=. Pero... yo los invito a evitar esos m√©todos si no es
      indispensable a la de s√≠ o s√≠ emplearlos.
- Calificaci√≥n :: 6

** Rangel Jose
- Documentaci√≥n :: [[./RangelJose/README.md][README.md]]
- Archivos :: [[./RangelJose/asesor.py][asesor.py]]
- Comentarios ::
  - ¬°10 a 20 sillas! El d√≠a que me quepan tantas sillas en mi
    cub√≠culo... ¬°tal vez si me hacen director de algo! üòâ
  - Identificaste una soluci√≥n basada en sem√°foros para que el
    profesor pueda dormir la siesta, y el primer alumno que llegue lo
    despierte. Es, s√≠, una viariaci√≥n sobre lo que hac√≠amos con el
    /Apagador/. ¬°Muy bien!
  - Veo √∫nicamente como faltante un par de /Mutexes/ sibre estructuras
    comunes, que se leen o modifican en diferentes lugares del c√≥digo
    sin ser protegidas (p.ej. =orden_preguntas=, =lista_alumnos=)
  - ¬°Muy bueno que encuentres c√≥mo resolver las preguntas en orden!
    Ingenioso sin duda, y muy buen razonamiento que presentas. Lo
    mismo respecto a un "desordenamiento a prop√≥sito" de los alumnos.
- Calificaci√≥n :: 9

* El elevador

** Arellano Israel
- Documentaci√≥n :: [[./ArellanoIsrael/ElevadorT2.txt][ElevadorT2.txt]]
- Archivos :: [[./ArellanoIsrael/elevador.py][elevador.py]]
- Comentarios ::
  - En el problema anterior felicit√© a los cinco alumnos que lo
    resolvieron porque los cinco pusieron los valores /duros/
    claramente anclados a valores parametrizados fuera del flujo
    central. Te sugiero adoptar esas pr√°cticas, te permiten realizar
    c√≥digo m√°s flexible (y te ahorran el tener que poner advertencias
    por el estilo de /¬°todo se va a romper si no son cinco los que se
    suben!/ por todos lados.
    - Este es meramente un comentario, no te resto puntos ni
      nada. Pero es una fuerte recomendaci√≥n.
  - ¬°Interesante soluci√≥n usando variables de condici√≥n! ¬°Muy bien!
    - Me parece que esto lleva a fragmentos con l√≥gica m√°s bien
      complicada, como las verificaciones en las l√≠neas 79--82 ‚Äî pero
      es absolutamente correcto.
  - Muy bueno que hagas las verificaciones en =mueve_elevador()=; casi
    siempre he visto implementaciones en que el elevador baja hasta el
    0 y sube hasta el 4 independientemente de alguien lo haya llamado
    üòâ
- Calificaci√≥n :: 10

** Bernal Gustavo, Toledo Dilan
- Documentaci√≥n :: [[./BernalGustavo-ToledoDilan/Entrega.txt][Entrega.txt]]
- Archivos :: [[./BernalGustavo-ToledoDilan/Elevador.py][Elevador.py]]
- Comentarios ::
  - La idea de un /Multiplex/ para limitar el m√°ximo de alumnos en el
    elevador es buena, pero... ¬°no llaman a =subir_elevador()= ni
    =bajar_elevador()=! (ni esas funciones hacen nada m√°s que
    adquirir/liberar el /Multiplex/)
  - Tambi√©n, la idea de formarse en la cola de cada piso. ¬°pero nunca
    se salen de la fila para abordar al elevador! üôÅ
- Calificaci√≥n :: 6

** Rojas Laylet, Ruiz Miguel
- Documentaci√≥n :: [[./RojasLaylet-RuizMiguel/Read.txt][Read.txt]]
- Archivos :: [[./RojasLaylet-RuizMiguel/Elevator.py][Elevator.py]]
- Comentarios ::
  - ¬°Muy bonita implementaci√≥n! (incluyendo una buena visualizaci√≥n
    para explicar la situaci√≥n)
  - Como correctamente indican, =Alumno.run()= incurre en /dos/
    esperas activas. Eso no es bueno... Claro, no es trivial evitarlo:
    el elevador =System= tendr√≠a que notificar a cada uno de los
    alumnos de las colas relevantes (y de dentro del elevador) para
    evitarlo, lo cual pondr√≠a de cabeza la l√≥gica que supongo ya
    llevaban desarrollada para el momento en que decidieron s√≠ dejar
    la espera activa.
- Calificaci√≥n :: 9

** Rosado Jorge
- Documentaci√≥n :: ---
- Archivos :: [[./RosadoKareem/Elevador.py][Elevador.py]]
- Comentarios ::
  - ¬°Una disculpa por la calificaci√≥n tard√≠a! Entregaste fuera de
    lugar, y cuando corregiste la entrega... no califiqu√© sino hasta
    apenas ahora
  - =Elevador#capacity= es constante (5); lo usas para reportar
    cu√°ntas personas bajan en alg√∫n piso. Me parece que quer√≠as decir
    =Elevador#passengers=, ¬øno?
  - Me parece que los pasajeros bajan todos siempre al llegar al piso
    5, a pesar que que cada uno de ellos prefiere un piso diferente
    Como sea, si bien tiene sus problemas, la implementaci√≥n es buena
    y limpia. ¬°Felicidades!
- Calificaci√≥n :: 8

* Intersecci√≥n de caminos

** Camacho Juan
- Documentaci√≥n :: [[./CamachoJuan/Tarea1.txt][Tarea1.txt]]
- Archivos :: [[./CamachoJuan/interseccion_de_caminos.py][interseccion_de_caminos.py]]
- Comentarios ::
  - ¬°Conciso y corto! ¬°Muy bien!
    - Me gust√≥ c√≥mo abstraes desde temprano, y c√≥mo esto ayuda a que
      el c√≥digo sea m√°s corto y sencillo.
  - Como lo indicas, tu =Mutex= alrededor de toda la intersecci√≥n
    evita que compartan los carriles no-rivales (p.ej. que 0 y 1 pase
    a la vez que 2 y 3)
    - Sin embargo, quitando al =Mutex= (y agreg√°ndole un =sleep(0.01)=
      despu√©s del =print= de cada cuadrante), me da una interacci√≥n
      mucho m√°s interesante:
      #+begin_src text
	Nuevo carro üöó numero: 0 Voy del norte hacia el sur ‚¨áÔ∏è
	carro: 0 üõë pasando por el cuadrante  0
	Nuevo carro üöó numero: 1 Voy del sur hacia el norte ‚¨ÜÔ∏è
	carro: 1 üõë pasando por el cuadrante  2
	Nuevo carro üöó numero: 2 Voy del sur hacia el norte ‚¨ÜÔ∏è
	Nuevo carro üöó numero: 3 Voy del sur hacia el norte ‚¨ÜÔ∏è
	Nuevo carro üöó numero: 4 Voy del este hacia el oeste ‚¨ÖÔ∏è
	carro: 4 üõë pasando por el cuadrante  1
	Nuevo carro üöó numero: 5 Voy del oeste hacia el este ‚û°Ô∏è
	carro: 5 üõë pasando por el cuadrante  3
	Nuevo carro üöó numero: 6 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 7 Voy del norte hacia el sur ‚¨áÔ∏è
	Nuevo carro üöó numero: 8 Voy del norte hacia el sur ‚¨áÔ∏è
	Nuevo carro üöó numero: 9 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 10 Voy del sur hacia el norte ‚¨ÜÔ∏è
	Nuevo carro üöó numero: 11 Voy del norte hacia el sur ‚¨áÔ∏è
	Nuevo carro üöó numero: 12 Voy del norte hacia el sur ‚¨áÔ∏è
	Nuevo carro üöó numero: 13 Voy del oeste hacia el este ‚û°Ô∏è
      #+end_src
      Los cuatro cuadrantes son ocupados al mismo tiempo. Los dem√°s
      autos que llegan al cruce (como es tristemente habitual üòõ)
      tienen que esperar a su turno. Un rato despu√©s, por alguna raz√≥n
      los autos est√°n acomodados para pasar sin chocarse. Ojo, baj√©
      el total de autos a 99, por practicidad:
      #+begin_src text
	Nuevo carro üöó numero: 94 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 95 Voy del norte hacia el sur ‚¨áÔ∏è
	Nuevo carro üöó numero: 96 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 97 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 98 Voy del sur hacia el norte ‚¨ÜÔ∏è
	carro: 7 üõë pasando por el cuadrante  0
	carro: 2 üõë pasando por el cuadrante  2
	carro: 15 üõë pasando por el cuadrante  1
	carro: 6 üõë pasando por el cuadrante  3
	carro: 8 üõë pasando por el cuadrante  0
	carro: 3 üõë pasando por el cuadrante  2
	carro: 21 üõë pasando por el cuadrante  1
      #+end_src
      Y por √∫ltimo, van saliendo; cada vez que uno deja el √∫ltimo
      cuadrante que ocupaba, notifica:
      #+begin_src text
	carro: 63 üõë pasando por el cuadrante  3
	carro üöó numero: 27 Sali del cruce!!! üéâüéâüéâ
	carro: 30 üõë pasando por el cuadrante  2
	carro üöó numero: 53 Sali del cruce!!! üéâüéâüéâ
	carro: 55 üõë pasando por el cuadrante  0
	carro üöó numero: 48 Sali del cruce!!! üéâüéâüéâ
	carro: 51 üõë pasando por el cuadrante  1
	carro üöó numero: 63 Sali del cruce!!! üéâüéâüéâ
	carro: 64 üõë pasando por el cuadrante  3
	carro üöó numero: 30 Sali del cruce!!! üéâüéâüéâ
	carro: 37 üõë pasando por el cuadrante  2
      #+end_src
    - El √∫nico problema con esto es que una gran cantidad de autos se
      estar√≠a quedando en la rayita del camell√≥n... Pero... ¬øY si
      limitamos el total de autos en el cruce a un n√∫mero
      decente... Digamos, 6? Revivamos tu =Mutex= y convirt√°moslo en
      un /Multiplex/ inicializ√°ndolo a =Semaphore(6)=, y la
      interacci√≥n se ve, desde el principio, mucho m√°s interesante:
      #+begin_src text
	Nuevo carro üöó numero: 0 Voy del norte hacia el sur ‚¨áÔ∏è
	carro: 0 üõë pasando por el cuadrante  0
	carro: 0 üõë pasando por el cuadrante  3
	carro üöó numero: 0 Sali del cruce!!! üéâüéâüéâ
	Nuevo carro üöó numero: 1 Voy del oeste hacia el este ‚û°Ô∏è
	carro: 1 üõë pasando por el cuadrante  3
	carro: 1 üõë pasando por el cuadrante  2
	carro üöó numero: 1 Sali del cruce!!! üéâüéâüéâ
	Nuevo carro üöó numero: 2 Voy del norte hacia el sur ‚¨áÔ∏è
	carro: 2 üõë pasando por el cuadrante  0
	carro: 2 üõë pasando por el cuadrante  3
	Nuevo carro üöó numero: 3 Voy del norte hacia el sur ‚¨áÔ∏è
	carro: 3 üõë pasando por el cuadrante  0
	carro üöó numero: 2 Sali del cruce!!! üéâüéâüéâ
	carro: 3 üõë pasando por el cuadrante  3
	Nuevo carro üöó numero: 4 Voy del oeste hacia el este ‚û°Ô∏è
	carro üöó numero: 3 Sali del cruce!!! üéâüéâüéâ
	Nuevo carro üöó numero: 5 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 7 Voy del oeste hacia el este ‚û°Ô∏è
	Nuevo carro üöó numero: 8 Voy del sur hacia el norte ‚¨ÜÔ∏è
	Nuevo carro üöó numero: 9 Voy del este hacia el oeste ‚¨ÖÔ∏è
	carro: 4 üõë pasando por el cuadrante  3
	Nuevo carro üöó numero: 6 Voy del norte hacia el sur ‚¨áÔ∏è
	carro: 9 üõë pasando por el cuadrante  1
	carro: 6 üõë pasando por el cuadrante  0
	carro: 5 üõë pasando por el cuadrante  3
	carro: 8 üõë pasando por el cuadrante  2
      #+end_src
- Calificaci√≥n :: 9

** Miranda Juan
- Documentaci√≥n :: [[./MirandaJuan/tarea_1.txt][tarea_1.txt]]
- Archivos :: [[./MirandaJuan/tarea1_interseccion_de_caminos.py][tarea1_interseccion_de_caminos.py]]
- Comentarios ::
  - La l√≥gica que implementas no resuelve al problema planteado
    - La barrera para que s√≥lo pasen los autos de 5 en 5 no tiene nada
      que ver con el planteamiento
    - No est√° modelada la intersecci√≥n
    - Por m√°s que confundiste escribiendo =Choches= en vez de
      =Coches=, no hay posibilidad alguna de =choques= üòâ
- Calificaci√≥n :: 6

** Rios Gamaliel
- Documentaci√≥n :: [[./RiosGamaliel/README.md][README.md]]
- Archivos :: [[./RiosGamaliel/1/Carril.java][Carril.java]], [[./RiosGamaliel/1/InterseccionCaminos.java][InterseccionCaminos.java]], [[./RiosGamaliel/1/TipoAuto.java][TipoAuto.java]], [[./RiosGamaliel/2/Carril.java][Carril.java]], [[./RiosGamaliel/2/InterseccionCaminos.java][InterseccionCaminos.java]], [[./RiosGamaliel/2/TipoAuto.java][TipoAuto.java]], [[./RiosGamaliel/2/TipoCarril.java][TipoCarril.java]]
- Comentarios ::
  - Es bueno que me saquen de la monoton√≠a üòâ ¬°Gracias por escribir en
    un lenguaje distinto de Python!
    - L√°stima que fuera Java... Tengo alguna especie de bloqueo
      mental, ¬°y nom√°s no puede caerme bien ese lenguaje!
    - (... pero esa es bronca m√≠a. ¬°Muy bien por hacerlo!)
  - ¬°Muy bien por encontrar la situaci√≥n de bloqueo mutuo, y hacer que
    sea imposible que se presente
    - Ojo, lo que describes es /bloqueo mutuo/, no /inanici√≥n/.
  - Tambi√©n buena: tu idea de adquirir =frente2= antes de liberar
    =frente1= (y, por tanto, imposibilitar el que nos quedemos
    atrapados en el camell√≥n esperando un mutex, como describo que le
    pas√≥ a mi modificaci√≥n del programa de Juan Camacho).
  - Y muy bueno c√≥mo aprovechaste los mecanismos espec√≠ficos de
    sincronizaci√≥n de la VM de Java (como =synchronized=). ¬°Yo cre√≠a
    que s√≥lo se pod√≠a anotar como =synchronized= a un m√©todo completo!
- Calificaci√≥n :: 10

** Uriarte Yahir
- Documentaci√≥n :: [[./UriarteYahir/Tarea1_Uriarte_Yahir.txt][Tarea1_Uriarte_Yahir.txt]]
- Archivos :: [[./UriarteYahir/IntersecciondeCaminos.py][IntersecciondeCaminos.py]], [[./UriarteYahir/IntersecciondeCaminosF.py][IntersecciondeCaminosF.py]]
- Comentarios ::
  - ¬°Ojo con la ortograf√≠a! No se escribe ¬´z¬ª antes de ¬´e¬ª, por lo que
    la palabra correcta es ¬´cruce¬ª, no ¬´cruze¬ª. La le√≠ ya tantas veces
    que... no puedo seguir leyendo sin hacerlo expl√≠cito üòâ
  - Revisando el error a que haces referencia, la respuesta casi
    siempre la tienes en el punto en que indica el tipo de excepci√≥n
    que ocurri√≥, =RuntimeError=. Reproduzco de tu documentaci√≥n, para
    que quede m√°s a mano para tus compa√±eros:
    #+begin_src text
      Traceback (most recent call last):

	File C:\Program Files\Spyder\pkgs\spyder_kernels\py3compat.py:356 in compat_exec
	  exec(code, globals, locals)

	File c:\users\yahir\documents\fi unam\semestre_2023-2\sistemas operativos\untitled6.py:165
	  thread.join()

	File threading.py:1008 in join

      RuntimeError: cannot join current thread
    #+end_src
    Esto es causado por el siguiente c√≥digo:
    #+begin_src python
      for thread in threading.enumerate():#Enumerar hilos.
	  if thread.daemon:
	      continue
	  try:
	      thread.join()
	  except RuntimeError as err:
	      if 'Error' in err.args[0]:
		  continue
	      else:
		  raise
    #+end_src
    La √∫ltima l√≠nea de tu mensaje de error (no entiendo qu√© busca el
    bloque =except= que le agregaste) se presenta porque =cannot join
    current thread=: No puedes pedir que el hilo actual espere para
    unirse consigo mismo. Si quieres evitar ese mensaje, usa el
    siguiente contenido para el bloque =expect=:
    #+begin_src python
      if thread != threading.current_thread():
	  thread.join()
    #+end_src
  - Me entregas dos implementaciones, pero... ¬øCu√°l se supone que
    revise? Viendo r√°pidamente tu descripci√≥n, me parece que la
    "mejor" es =IntersecciondeCaminos.py= comprender√°s que no revise
    ambas (¬°requieren su tiempo!)
  - Tu c√≥digo no evita (s√≥lo detecta) las colisiones: Es frecuente que
    veamos que =ya cochocaron üöëüöëüöëüöëüöë=.
  - Me parece que caes en un bloqueo mutuo: Si bien a veces el
    programa ejecuta correctamente, casi siemprese presenta un bloqueo
    mutuo. Al interrumpirlo me indica que:
    #+begin_src text
      ^CTraceback (most recent call last):
	File "/home/gwolf/vcs/sistop-2023-2/tareas/1/UriarteYahir/IntersecciondeCaminos.py", line 85, in <module>
	  thread.join()
	File "/usr/lib/python3.11/threading.py", line 1112, in join
	  self._wait_for_tstate_lock()
	File "/usr/lib/python3.11/threading.py", line 1132, in _wait_for_tstate_lock
	  if lock.acquire(block, timeout):
	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      KeyboardInterrupt
    #+end_src
    - Pero esto s√≥lo me indica que el hilo principal se qued√≥
      esperando en el =join()=, no me dice d√≥nde se quedaron los otros hojis.

    - Puedes depurarlo m√°s, me gustar√≠a que nos cuentes en qu√© te
      atoraste üòâ
    
- Calificaci√≥n :: 7

* El cruce del r√≠o

** Frias Camille
- Documentaci√≥n :: [[./FriasCamille/Explicacion.txt][Explicacion.txt]]
- Archivos :: [[./FriasCamille/convenci√≥n.py][convenci√≥n.py]]
- Comentarios ::
  - ¬°Deja de lado el /pensamiento m√°gico/! Si tienes un error que no
    siempe se presenta, no es /por misterios de la vida/... Casi
    seguramente es una condici√≥n de carrera, y tienes todo lo
    necesario para corregirla üòâ
    - "Desafortunadamente"... Ejecut√© varias veces el programa, y
      nunca lo vi fallar...
    - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
      Yourself/. *No te repitas*.

      Si tienes dos funciones no-triviales tan similares como
      =hacker()= y =serf()=, convendr√≠a plantear un par√°metro que
      definiera su comportamiento, posiblemente las cadenas que
      imprime... y escribir √∫nicamente una vez la l√≥gica. As√≠ como lo
      hiciste, cualquier cambio o correcci√≥n que tengas que hacer,
      debes hacerla en dos lugares. Es m√°s trabajo mantenerlo, al
      igual que verificar que ambas copias funcionen bien.
  - La l√≥gica del programa me parece correcta y simple. ¬°Muy bien!
- Calificaci√≥n :: 10

** Ju√°rez Cristopher, Constantino Pablo
- Documentaci√≥n :: [[./ConstantinoPablo-JuarezCristopher/README.md][README.md]]
- Archivos :: [[./ConstantinoPablo-JuarezCristopher/CruceRio.py][CruceRio.py]]
- Comentarios ::
  - Su l√≥gica general es buena, y (¬°bien!) utilizan mecanismos de
    sincronizaci√≥n para detener / se√±alizar a los hilos.

    Sin embargo, hacen muchas verificaciones y modificaciones a
    variables globales (=num_Hackers=, =num_Serfs=) sin emplear un
    /Mutex/ para protegerlas de accesos simult√°neos.
- Calificaci√≥n :: 8

** Marquez Axel
- Documentaci√≥n :: [[./MarquezAxel/Especificacion.txt][Especificacion.txt]]
- Archivos :: [[./MarquezAxel/CruceRio.py][CruceRio.py]]
- Comentarios ::
  - Conciso, cortito, y f√°cil de leer. ¬°Bien! üòÉ
  - Sin embargo... Caes en bloqueo mutuo siempre, despu√©s de lanzar la
    primera balsa üò¢
    - Todos tus hilos hacen un =balsa.acquire()=, pero el √∫ltimo (el
      que ve que ya son 4 y le "da la patada" a la balsa) no lo
      hace. Esto es f√°cil de corregir: Tanto en =lanza_serf()= como en
      =lanza_hacker()= reemplaza el √∫ltimo caso del =if=, de:
      #+begin_src python
      else:
        balsa.release()
      #+end_src
      para que quede:
      #+begin_src python
      else:
        balsa.release()
      #+end_src
    - Pero todav√≠a no sirve bien üôÅ Ahora se llenan 3 balsas, pero
      siguen llegando hilos... y no sale ningun m√°s ‚òπ

      Esto es, me parece, porque usas =serf_cont= como un contador,
      pero nunca lo decrementas ‚Äî y haces las comparaciones =if
      serf_cont == Max=, =if serf_cont == 2 and hacker_cont == 2= y
      =if hacker_cont == 4=
  - El c√≥digo /muy en general/ funciona, la l√≥gica es correcta,
    pero... le faltan /varias/ peque√±as precisiones.
- Calificaci√≥n :: 7

** Martinez Licea, Santiago Alejandro
- Documentaci√≥n :: [[./MartinezLicea-SantiagoAlejandro/README.md][README.md]]
- Archivos :: [[./MartinezLicea-SantiagoAlejandro/balsa.py][balsa.py]]
- Comentarios ::
  - El c√≥digo como lo mandaron no sirve : Si todos hacen un
    =semaforoH.acquire()= o =semaforoS.acquire()= al iniciar, y √©stos
    est√°n inicializados a 0, todos los hilos se quedan dormidos para
    siempre
  - Los mensaje =La balsa ha cruzado= y =La balsa ha regresado= son
    impresos de forma no condicional, por cualquier hilo que pase por
    ah√≠
  - La l√≥gica para maneajar el conteo de navegantes... no existe üôÅ
- Calificaci√≥n :: 6

** Oronzor Manases
- Documentaci√≥n :: [[./OronzorManases/Informe.txt][Informe.txt]]
- Archivos :: [[./OronzorManases/El_cruce_del_rio.py][El_cruce_del_rio.py]]
- Comentarios ::
  - Respecto a tu duda: hay muchas maneras en que podr√≠as interrumpir
    la condici√≥n dependiendo de varias condiciones. En vez de lanzar
    los hilos dentro de un =while True=, podr√≠as generar un n√∫mero
    predefinido de hilos:
    #+begin_src python
      desarrolladores = 0
      while desarrolladores < 40:
	  if random.randint(0, 1) == 0:
	      threading.Thread(target=hacker,).start()
	  else:
	      threading.Thread(target=serf,).start()
    #+end_src
    Podr√≠as contar el n√∫mero de balsas que han cruzado. Podr√≠as
    hacerlo basado en tiempo, o en entrada de teclado... ¬°lo que quieras!
    - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
      Yourself/. *No te repitas*.

      Si tienes dos funciones no-triviales tan similares como
      =hacker()= y =serf()=, convendr√≠a plantear un par√°metro que
      definiera su comportamiento, posiblemente las cadenas que
      imprime... y escribir √∫nicamente una vez la l√≥gica. As√≠ como lo
      hiciste, cualquier cambio o correcci√≥n que tengas que hacer,
      debes hacerla en dos lugares. Es m√°s trabajo mantenerlo, al
      igual que verificar que ambas copias funcionen bien.
- Calificaci√≥n :: 10

** Paniagua Eduardo
- Documentaci√≥n :: [[./PaniaguaEduardo/tarea01_eduardoPaniagua.txt][tarea01_eduardoPaniagua.txt]]
- Archivos :: [[./PaniaguaEduardo/tarea01_eduardoPaniagua.py][tarea01_eduardoPaniagua.py]]
- Comentarios ::
  - Buena implementaci√≥n
  - ¬°Ojo! En tu documentaci√≥n dices que /Para resolver este ejercicio
    se ocuparon 2 hilos, uno que corresponde a los serfs y otro que
    corresponde a los hackers/. ¬øEst√°s seguro? üòâ

    Aqu√≠, en efecto, lanzas dos hilos:
    #+begin_src python
      Thread(target=lanzarSerf).start()
      Thread(target=lanzarHacker).start()
    #+end_src
    - Sin embargo, tanto en =lanzarSerf()= como en =lanzarHacker()=
      tienes:
      #+begin_src python
	for i in range(12):
	    Thread(target=serf, args=[i].start()
      #+end_src
    - As√≠ que trabajas con 1 (hilo principal) + 2 (lanzarHacker y
      lanzarSelf), + 12 hackers + 12 serfs.
- Calificaci√≥n :: 10

** Ramirez Daniel
- Documentaci√≥n :: [[./RamirezDaniel/ProblemaCruceDelR√≠o.txt][ProblemaCruceDelR√≠o.txt]]
- Archivos :: [[./RamirezDaniel/cruceDelRio.py][cruceDelRio.py]]
- Comentarios ::
  - Tu c√≥digo est√° hecho para resopnder a un n√∫mero exacto de /serfs/
    y /hackers/, y s√≥lo responde a sus respectivas llegadas de la
    misma proporci√≥n.
  - Lanzas un hilo para hackers, un hilo para threads, y un hilo para
    cruzar juntos
    - Ser√≠a como poner tres balsas en el r√≠o, cada una de ellas
      "reservada" para una composici√≥n espec√≠fica de usuarios
- Calificaci√≥n :: 7

** Rivera Mauricio, Ruiz Laura
- Documentaci√≥n :: [[./RiveraMauricio-RuizLaura/README.md][README.md]]
- Archivos :: [[./RiveraMauricio-RuizLaura/balsas.py][balsas.py]]
- Comentarios ::
  - ¬°Muy bien por parametrizar todo! De hecho, esta soluci√≥n me da pie
    a pensar en un /refinamiento/: ¬øY c√≥mo lo haces si el n√∫mero de
    asientos es parametrizable? ¬øFunciona si =soporte_barca=6= ? ¬°s√≠,
    s√≠ funciona! Tienen que entrar de 2 en 2, pero pueden entrar hasta
    6 üòâ
  - ¬°Felicidades, muy buen trabajo!
- Calificaci√≥n :: 10

** Rojo Luis
- Documentaci√≥n :: [[./RojoLuis/cruce_del_rio_doc.txt][cruce_del_rio_doc.txt]]
- Archivos :: [[./RojoLuis/cruce_del_rio.py][cruce_del_rio.py]]
- Comentarios ::
  - ¬°Muy bueno, que encuentres inspiraci√≥n en otros problemas vistos
    en clase! üòâ Muy bonita idea el uso de intermediarios. ¬°Y muy
    orignal!
- Calificaci√≥n :: 10

** Sotelo Axel
- Documentaci√≥n :: [[./SoteloAxel/reporte.txt][reporte.txt]]
- Archivos :: [[./SoteloAxel/tarea1.py][tarea1.py]]
- Comentarios ::
  - Siempre que puedas, recuerda el principio "DRY": /Don't Repeat
    Yourself/. *No te repitas*.

    Si tienes dos funciones no-triviales tan similares como
    =hacker()= y =serf()=, convendr√≠a plantear un par√°metro que
    definiera su comportamiento, posiblemente las cadenas que
    imprime... y escribir √∫nicamente una vez la l√≥gica. As√≠ como lo
    hiciste, cualquier cambio o correcci√≥n que tengas que hacer,
    debes hacerla en dos lugares. Es m√°s trabajo mantenerlo, al
    igual que verificar que ambas copias funcionen bien.
  - ¬°Encontr√© el problema en tu l√≥gica que hace que tengas que
    inicializar =lugaresBalas= a 5:
    - Recuerda que les expliqu√© que indentar un bloque bajo =with
      lugaresBalas:= es equivalente a rodearlo con un
      =lugaresBalas.acquire()= / =lugaresBalas.release()=.
    - Entonces, para fines pr√°cticos, para hacer cualquier cosa en
      =hacker()= o en =serf()= necesitas tener /dos veces/ el mismo
      =Multiplex=.
    - ¬øQu√© hacer? Quita uno o el otro. Puede quedar as√≠:
      #+begin_src python
	def hacker():
	    global numHackers
	    print("hacker llega ‚ö´")

	    while True:
		time.sleep(random.random())
		with lugaresBalas:
		    persona = 'hacker'
		    print(f"{persona} {numHackers} se pone en fila para subir")
		    numHackers = numHackers+1

		lugaresBalas.release()
#+end_src
- Calificaci√≥n :: 9

* Santa Claus

** Garcia Lopez, Martinez Julio
- Documentaci√≥n :: [[./GarciaLopez-MartinezJulio/ExplicacionTarea1SO.txt][ExplicacionTarea1SO.txt]]
- Archivos :: [[./GarciaLopez-MartinezJulio/Tarea1SO.py][Tarea1SO.py]]
- Comentarios ::
  - ¬°Muy bien! Me gusta c√≥mo usan a =SemSanta= como un an√°logo a /dos/
    barreras distintas (el mismo sem√°foro se abre con 9 renos o con 3
    elfos).
  - ¬°Ojo! Falta un par de mutexes para proteger el acceso concurrente
    a variables globales (p.ej. para =numRenos= en =reno()=, para
    =numElfos= en =elfo()=
  - Y ya que estamos criticando todo lo criticable üòâ ¬°Todos los a√±os
    debe haber navidad! *¬°TODOS!* ¬øQu√© es eso de terminar despu√©s de
    s√≥lo un recorrido? Si hay un ejemplo de =while True=, ese deber√≠a
    ser Santa Claus üòâ
- Calificaci√≥n :: 8

** Meneses Erick, Mex Aerin
- Documentaci√≥n :: [[./MenesesErick-MexAerin/README.txt][README.txt]]
- Archivos :: [[./MenesesErick-MexAerin/Tarea1-Santa.py][Tarea1-Santa.py]]
- Comentarios ::
  - Muy buena implementaci√≥n y *muy* buena documentaci√≥n. Clara y
    detallada. ¬°Felicidades! üòÉ
- Calificaci√≥n :: 10

** Sanchez Marco, Teran Mario
- Documentaci√≥n :: [[./SanchezMarco-TeranMario/README.md][README.md]]
- Archivos :: [[./SanchezMarco-TeranMario/main.c][main.c]]
- Comentarios ::
  - ¬°Muy bien! ¬°Todav√≠a hay gente que se anima a resolver mis
    problemas en lenguajes que no sean Python! üòâ ¬°Bienvenido C!
  - No se disculpen por la acentuaci√≥n (que no /asentuasion/):
    Corr√≠janla. En serio, es un punto importante. Yo uso teclado
    en_US; hay muchas manteras de configurarle teclas para
    acentuar. Yo uso un teclado definido a medida en =xkb=.
  - Curioso el orden de eventos que manejan para despertar a Santa
    - En la bit√°cora aparece:
      #+begin_quote
      Santa esta durmiendo.
      Elfo 2 le da lata a Santa Claus.
      Elfo 1 le da lata a Santa Claus.
      Santa se despierta y ayuda a los elfos.
      Elfo 3 le da lata a Santa Claus.
      Santa se despierta e inicia su recorrido.
      Reno 2 regresa de sus vacaciones y esta listo.
      Reno 4 regresa de sus vacaciones y esta listo.
      Reno 3 regresa de sus vacaciones y esta listo.
      Reno 8 regresa de sus vacaciones y esta listo.
      Reno 6 regresa de sus vacaciones y esta listo.
      Reno 9 regresa de sus vacaciones y esta listo.
      Reno 1 regresa de sus vacaciones y esta listo.
      Reno 5 regresa de sus vacaciones y esta listo.
      Reno 7 regresa de sus vacaciones y esta listo.
      #+end_quote
    - Revis√© la l√≥gica, y es correcta... Pero... ¬øC√≥mo est√° eso de que
      Santa se despierta e inicia su recorrido... /Justo antes/ de que
      lleguen los renos? ¬øSer√° que los est√° queriendo reemplazar por
      una m√°quina fr√≠a y sin coraz√≥n?
    - Como dije, la l√≥gica es /casi/ correcta. Yo sugerir√≠a cambiar
      s√≥lo el punto del =printf=. En su versi√≥n:
      #+begin_src c
	if(no_renos == NO_TOTAL_RENOS) {
		printf("Santa se despierta e inicia su recorrido.\n");
		for(int i=0; i<NO_TOTAL_RENOS; i++)
			sem_post(&sem_reno);
		no_renos = 0;
	} else if(no_elfos == NO_PERMITIDO_ELFOS)
		printf("Santa se despierta y ayuda a los elfos.\n");
      #+end_src
      Yo har√≠a:
      #+begin_src c
	if(no_renos == NO_TOTAL_RENOS) {
		for(int i=0; i<NO_TOTAL_RENOS; i++)
			sem_post(&sem_reno);
		no_renos = 0;
		printf("Santa se despierta e inicia su recorrido.\n");
	} else if(no_elfos == NO_PERMITIDO_ELFOS)
		printf("Santa se despierta y ayuda a los elfos.\n");
      #+end_src
    - Algo parecido con los elfos: Imprimir =Elfo %d le da lata a Santa
      Claus= ocurre /casi/ siempre dos veces, luego se despierta
      Santa, y luego vuelve a imprimirse.
- Calificaci√≥n :: 10

** Solis Alan
- Documentaci√≥n :: [[./SolisAlan/Explicacion.txt][Explicacion.txt]]
- Archivos :: [[./SolisAlan/santa.py][santa.py]]
- Comentarios ::
  - Bueno... Como ver√°s que le respond√≠ a tu compa√±ero Fernando, hubo
    al menos un caso de otro compa√±ero que s√≠ resolvi√≥ (de una forma
    distinta a la que hicimos en clase) el problema de gatos y
    ratones.
    - ¬°pero qu√© bueno que t√∫ s√≠ seguiste las indicaciones! üòâ
  - OK, veo varias partes de la soluci√≥n muy bien implementadas en tu
    problema. Muy bien por identificar e implementar a las barreras.
  - Me parece interesante que sea =Santa()= quien realice las
    verificaciones (si ya son suficientes =elfos()= o =renos()=) y suelte las
    llamadas para que estos despierten / contin√∫en.
- Calificaci√≥n :: 10

** V√°zquez Fredin
- Documentaci√≥n :: [[./V√°zquezFredin/Images/1.jpg][1.jpg]], [[./V√°zquezFredin/Images/2.jpg][2.jpg]], [[./V√°zquezFredin/Images/demo.gif][demo.gif]], [[./V√°zquezFredin/README.md][README.md]]
- Archivos :: [[./V√°zquezFredin/Santa_problem.py][Santa_problem.py]]
- Comentarios ::
  - ¬°Guau! Tu documentaci√≥n me dej√≥ francamente
    sorprendido. ¬°Buen√≠sima, super completa y bastante clara! üòÉ
  - Recomendaci√≥n pra el c√≥digo: Me parece muy buena tu idea de
    mantener la legibilidad separando el c√≥digo de los mensajes que se
    imprimen. Sin embargo, es m√°s claro (e incluso, t√≠picamente m√°s
    r√°pido, aunque en el nivel de lo √≠nfimo) usar un hash
    ("diccionario" en Python) que una cantidad de funciones. Esto,
    adem√°s, te permite separar los mensajes tem√°ticamente. Por
    ejemplo, en vez de:
    #+begin_src python
      def inicio_viaje():
	  print(Fore.LIGHTGREEN_EX +"\t\t\t\t * Santa inicia el viaje *  \U0001F30E \n\t      \U0001F384      \U0001F381 F e l i z  N a v i d a d !   H o !   H o !   H o !  \U0001F381"+ Style.RESET_ALL)

      def ayudar_elfos():
	  print(Fore.GREEN+"\t\t¬øEn qu√© les puedo ayudar?         * Empieza asesorar *"+ Style.RESET_ALL)

      def santa_regresa():
	  print(Fore.LIGHTBLUE_EX+" > * Santa Claus regresa del viaje muy cansado y se va a dormir \U0001F6CC *"+ Style.RESET_ALL)

      def santa_duerme():
	  print(Fore.LIGHTBLUE_EX+"* Santa Claus vuelve a dormir \U0001F6CC *"+ Style.RESET_ALL)

      def reno_llega(num):
	  print(f"\t * El reno {num} \U0001F98C regres√≥ de sus vacaciones *")

      def renos_descansan():
	  print("* El reno procede a descansar en el establo \U0001F4A4 *")

      def reno_aviso(id):
	  print(Fore.LIGHTYELLOW_EX + f"\t\t### Ha llegado el √∫ltimo reno ###          ~~ Ahora el reno {id} se dirige con Santa Claus ~~" + Style.RESET_ALL)

      def renos_preparados(num):
	  print(f"\t\t~~~~~~      El reno {num} ya est√° listo para el viaje!      ~~~~~~")

      def renos_vacacionar():
	  print(Fore.LIGHTRED_EX+" > * Los renos vuelven a ir de vacaciones \U0001F3D6 *"+ Style.RESET_ALL)

      def grupo_formado_aviso(num):
	  print(Fore.LIGHTYELLOW_EX+f"\t> Elfo n√∫mero {num}: El grupo ya est√° formado ¬°Ya podemos preguntar!  \U0001F512\U0001F5DD"+ Style.RESET_ALL)

      def elfo_recibe_ayuda(id):
	  print(f"* Elfo n√∫mero {id} recibe ayuda por parte de Santa Claus *")
    #+end_src
    yo te sugerir√≠a usar:
    #+begin_src python
      cadenas = {
	  'santa': {
	      # (...)
	      'inicio_viaje': Fore.LIGHTGREEN_EX +"\t\t\t\t * Santa inicia el viaje *  \U0001F30E \n\t      \U0001F384      \U0001F381 F e l i z  N a v i d a d !   H o !   H o !   H o !  \U0001F381"+ Style.RESET_ALL,
	      'ayudar_elfos': Fore.GREEN+"\t\t¬øEn qu√© les puedo ayudar?         * Empieza asesorar *"+ Style.RESET_ALL,
	      'regresa': Fore.LIGHTBLUE_EX+" > * Santa Claus regresa del viaje muy cansado y se va a dormir \U0001F6CC *"+ Style.RESET_ALL,
	      'duerme': Fore.LIGHTBLUE_EX+"* Santa Claus vuelve a dormir \U0001F6CC *"+ Style.RESET_ALL,
	      },
	  'reno': {
	      'llega': f"\t * El reno {num} \U0001F98C regres√≥ de sus vacaciones *",
	      'descansa': "* El reno procede a descansar en el establo \U0001F4A4 *",
	      'aviso': Fore.LIGHTYELLOW_EX + f"\t\t### Ha llegado el √∫ltimo reno ###          ~~ Ahora el reno {id} se dirige con Santa Claus ~~" + Style.RESET_ALL,
	      'preparados': f"\t\t~~~~~~      El reno {num} ya est√° listo para el viaje!      ~~~~~~"
	      'vacaciona': Fore.LIGHTRED_EX+" > * Los renos vuelven a ir de vacaciones \U0001F3D6 *"+ Style.RESET_ALL,
	      'grupo_formado_aviso': Fore.LIGHTYELLOW_EX+f"\t> Elfo n√∫mero {num}: El grupo ya est√° formado ¬°Ya podemos preguntar!  \U0001F512\U0001F5DD"+ Style.RESET_ALL
	  },
	  'elfo': {
	      'recibe_ayuda': f"* Elfo n√∫mero {id} recibe ayuda por parte de Santa Claus *"
	      # (...)
	      }
	  }`
    #+end_src

    Claro, manejas alguns cadenas de formato, que habr√≠a que cambiar
    por los formatos tipo C ('%d' y similares) y substituirlos en la
    llamada. Otra idea ser√≠a cambiar las constantes de =colorama= por
    valores de m√°s f√°cil lectura que un =Fore.LIGHTYELLOW_EX= o
    similares.
- Calificaci√≥n :: 10

* Gatos y ratones

** Razo Fernando
- Documentaci√≥n :: [[./RazoFernando/TAREA 1 Ejercicios de sincronizaci√≥n.pdf][TAREA 1 Ejercicios de sincronizaci√≥n.pdf]]
- Archivos :: [[./RazoFernando/gatosYRatones.py][gatosYRatones.py]]
- Comentarios ::
  - Pero, pero... ¬°Este problema lo resolvimos en clase!
    ¬°Supuestamente este ya no estaba "abierto" para solucionar!
    - Lo doy por bueno, tu respuesta es suficientemente distinta y
      original a la que hicimos. Pero igual me sac√≥ de onda üòâ
  - Me parece interesante que el "control poblacional" recae por
    completo en los ratones ‚Äî es dentro de =RatonCome()= que se
    detecta si hay alg√∫n gato y si √©ste se comi√≥ al rat√≥n
- Calificaci√≥n :: 10

